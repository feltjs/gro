import {
	compile,
	type Options as Json_SchemaToTypeScriptOptions,
} from '@ryanatkn/json-schema-to-typescript';
import {traverse} from '@grogarden/util/object.js';

import type {Gen_Context, Raw_Gen_Result} from './gen.js';
import {to_gen_schema_name, type Gen_Module_Meta, type Schema_Gen_Module} from './gen_module.js';
import {normalize_type_imports} from './type_imports.js';
import {infer_schema_types, is_json_schema, type Json_Schema} from './schema.js';
import {to_root_path} from './paths.js';

export const gen_schemas = async (
	mod: Schema_Gen_Module,
	ctx: Gen_Context,
	options: Partial<Json_SchemaToTypeScriptOptions>,
): Promise<Raw_Gen_Result> => {
	const {imports, types} = await run_schema_gen(ctx, mod, options);
	const origin_root_path = to_root_path(ctx.origin_id);
	return `
		// generated by ${origin_root_path}

		${imports.join('\n;\n')}
		
    ${types.join(';\n\n')}

		// generated by ${origin_root_path}
	`;
};

const run_schema_gen = async (
	ctx: Gen_Context,
	mod: Schema_Gen_Module,
	options: Partial<Json_SchemaToTypeScriptOptions>,
): Promise<{imports: string[]; types: string[]}> => {
	const raw_imports: string[] = [];
	const types: string[] = [];

	// TODO BLOCK could parallelize but need to preserve order, map and flatten
	for (const schema_info of to_schema_info_from_module(mod)) {
		// both `infer_schema_types` and `json-schema-to-typescript` mutate the schema, so clone first
		const schema = structuredClone(schema_info.schema);
		infer_schema_types(schema, ctx); // process the schema, adding inferred data

		// Compile the schema to TypeScript.
		const identifier = to_gen_schema_name(schema_info.identifier);
		// eslint-disable-next-line no-await-in-loop
		const result = await compile(structuredClone(schema), identifier, {
			bannerComment: '',
			format: false,
			...options,
		});
		types.push(result);

		// Walk the original schema and add any imports with `tsImport`.
		traverse(schema, (key, v) => {
			if (key === 'tsImport') {
				if (typeof v === 'string') {
					raw_imports.push(v);
				} else if (Array.isArray(v)) {
					raw_imports.push(...v);
				}
			}
		});
	}

	const imports = await normalize_type_imports(raw_imports, ctx.origin_id);

	return {imports, types};
};

export const to_schemas_from_modules = (gen_modules: Gen_Module_Meta[]): Json_Schema[] => {
	const schemas: Json_Schema[] = [];
	for (const gen_module of gen_modules) {
		if (gen_module.type !== 'schema') continue;
		for (const schema_info of to_schema_info_from_module(gen_module.mod)) {
			schemas.push(schema_info.schema);
		}
	}
	return schemas;
};

const to_schema_info_from_module = (
	mod: Schema_Gen_Module,
): Array<{identifier: string; schema: Json_Schema}> => {
	const schema_info: Array<{identifier: string; schema: Json_Schema}> = [];
	for (const identifier in mod) {
		const value = mod[identifier];
		if (is_json_schema(value)) schema_info.push({identifier, schema: value});
	}
	return schema_info;
};
