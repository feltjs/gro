import {compile} from '@ryanatkn/json-schema-to-typescript';
import {stripEnd} from '@feltcoop/felt/util/string.js';

import {type GenContext, type RawGenResult} from './gen.js';
import {type SchemaGenModule} from './genModule.js';
import {toRootPath} from '../paths.js';

export const genSchemas = async (mod: SchemaGenModule, ctx: GenContext): Promise<RawGenResult> => {
	const {imports, types} = await runSchemaGen(mod);
	console.log(normalizeImports(imports));
	return `
    // generated by ${toRootPath(ctx.originId)}

    ${normalizeImports(imports).join(';\n')}

    ${types.join(';\n')}

    // generated by ${toRootPath(ctx.originId)}
  `;
};

export const runSchemaGen = async (
	mod: SchemaGenModule,
): Promise<{imports: string[]; types: string[]}> => {
	const imports: string[] = [];
	const types: string[] = [];

	for (const identifier in mod) {
		const value = mod[identifier];
		if (!isSchema(value)) continue;

		// Compile the schema to TypeScript.
		const finalIdentifier = stripEnd(identifier, 'Schema'); // convenient to avoid name collisions
		const result = await compile(value, finalIdentifier, {bannerComment: '', format: false});
		types.push(result);

		// Traverse the schema and add any imports with `tsImport`.
		traverse(value, (key, value) => {
			if (key === 'tsImport') {
				if (typeof value === 'string') {
					imports.push(value);
				} else if (Array.isArray(value)) {
					imports.push(...value);
				}
			}
		});
	}

	return {imports, types};
};

// This is like the ajv `SchemaObject` except that it requires `$id`.
// We may want to loosen this restriction,
// but for now it seems like a convenient way to disambiguate schemas from other objects
// while ensuring they can be registered with ajv and referenced by other schemas.
export interface SchemaObject {
	$id: string;
	[key: string]: unknown;
}

const isSchema = (value: unknown): value is SchemaObject =>
	!!value && typeof value === 'object' && '$id' in value;

// TODO upstream to Felt?
/**
 * Performs a depth-first traversal of an object, calling `cb` for every key and value.
 * @param obj Any object with enumerable properties.
 * @param cb Receives the key and value for every enumerable property on `obj` and its descendents.
 * @returns
 */
const traverse = (obj: any, cb: (key: string, value: any) => void): void => {
	if (!obj || typeof obj !== 'object') return;
	for (const k in obj) {
		const v = obj[k];
		cb(k, v);
		traverse(v, cb);
	}
};

const normalizeImports = (imports: string[]): string[] =>
	Array.from(new Set(imports.map(normalizeImport)));

// TODO technically this should lex the imports using the TS compiler
// (or esbuild? does es-module-lexer work with the `type` imports?)
// and then ideally group imports to the same module into the same statement
const normalizeImport = (str: string): string => {
	str = stripEnd(str.trim(), ';');
	if (str.endsWith('"')) {
		const idx = str.indexOf('"');
		if (idx === str.length - 1) return str; // malformed, just pass it through
		return str.substring(0, idx) + "'" + str.substring(idx + 1, str.length - 1) + "'";
	} else {
		return str;
	}
};
