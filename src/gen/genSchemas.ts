import {compile} from '@ryanatkn/json-schema-to-typescript';
import {stripEnd} from '@feltcoop/felt/util/string.js';

import {type GenContext, type RawGenResult} from './gen.js';
import {type SchemaGenModule} from './genModule.js';
import {toRootPath} from '../paths.js';

export const genSchemas = async (mod: SchemaGenModule, ctx: GenContext): Promise<RawGenResult> => {
	const {imports, types} = await runSchemaGen(mod);
	return `
    // generated by ${toRootPath(ctx.originId)}

    ${imports.join(';\n')}

    ${types.join(';\n')}

    // generated by ${toRootPath(ctx.originId)}
  `;
};

export const runSchemaGen = async (
	mod: SchemaGenModule,
): Promise<{imports: string[]; types: string[]}> => {
	const imports: string[] = [];
	const types: string[] = [];

	for (const identifier in mod) {
		const value = mod[identifier];
		if (!isSchema(value)) continue;

		// Compile the schema to TypeScript.
		const finalIdentifier = stripEnd(identifier, 'Schema'); // convenient to avoid name collisions
		const result = await compile(value, finalIdentifier, {bannerComment: '', format: false});
		types.push(result);

		// Traverse the schema and add any imports with `tsImport`.
		traverse(value, (key, value) => {
			if (key === 'tsImport') imports.push(value);
		});
	}

	return {imports, types};
};

// This is like the ajv `SchemaObject` except that it requires `$id`.
// We may want to loosen this restriction,
// but for now it seems like a convenient way to disambiguate schemas from other objects
// while ensuring they can be registered with ajv and referenced by other schemas.
export interface SchemaObject {
	$id: string;
	[key: string]: unknown;
}

const isSchema = (value: unknown): value is SchemaObject =>
	!!value && typeof value === 'object' && '$id' in value;

// TODO upstream to Felt?
/**
 * Performs a depth-first traversal of a value, calling `cb` for every key and value.
 * @param value Any value, but only useful for values with enumerable properties.
 * @param cb Receives the key and value for every enumerable property on `obj` and its descendents.
 * @returns
 */
const traverse = (value: any, cb: (key: string, value: any) => void): void => {
	for (const k in value) {
		const v = value[k];
		cb(k, v);
		traverse(v, cb);
	}
};
